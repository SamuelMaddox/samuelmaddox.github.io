"use strict";(self.webpackChunkdeveloper_notes=self.webpackChunkdeveloper_notes||[]).push([[620],{621:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"articles/avoid-hasty-abstractions-testing/index","title":"Avoid Hasty Abstractions Testing","description":"AUTHOR: Kent C. Dodds","source":"@site/docs/articles/avoid-hasty-abstractions-testing/index.md","sourceDirName":"articles/avoid-hasty-abstractions-testing","slug":"/articles/avoid-hasty-abstractions-testing/","permalink":"/articles/avoid-hasty-abstractions-testing/","draft":false,"unlisted":false,"editUrl":"https://github.com/samuelmaddox/samuelmaddox/blob/main/docs/articles/avoid-hasty-abstractions-testing/index.md","tags":[],"version":"current","lastUpdatedAt":1749129615000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"articlesSidebar","previous":{"title":"The Merits of Mocking","permalink":"/articles/the-merits-of-mocking"},"next":{"title":"Avoid the Test User","permalink":"/articles/avoid-the-test-user/"}}');var o=t(3420),i=t(3774);const a={sidebar_position:2},r="Avoid Hasty Abstractions Testing",l={},d=[{value:"ANA Testing",id:"ana-testing",level:2},{value:"DRY Testing",id:"dry-testing",level:2},{value:"AHA Testing",id:"aha-testing",level:2},{value:"AHA Testing with React",id:"aha-testing-with-react",level:2},{value:"Nesting",id:"nesting",level:2},{value:"jest-in-case and test.each",id:"jest-in-case-and-testeach",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"avoid-hasty-abstractions-testing",children:"Avoid Hasty Abstractions Testing"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"AUTHOR: Kent C. Dodds"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"POSTED: April 7th, 2019"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.em,{children:["LINK: ",(0,o.jsx)(n.a,{href:"https://kentcdodds.com/blog/aha-testing",children:"https://kentcdodds.com/blog/aha-testing"})]})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"/articles/avoid-hasty-abstractions-programming",children:"AHA Programming Principle"})," stands for \"Avoid Hasty Abstraction.\" I have specific feelings about how this applies to writing maintainable tests. Most of the tests that I've seen in the wild have been wildly on one side of the spectrum of abstraction: ANA (Absolutely No Abstraction), or completely DRY (Don't Repeat Yourself). (I made up ANA just now)."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"The Spectrum of Abstraction",src:t(4284).A+"",width:"1731",height:"265"})}),"\n",(0,o.jsx)(n.p,{children:"Finding a sweet spot in the middle of the spectrum of abstraction is key to developing maintainable tests."}),"\n",(0,o.jsx)(n.h2,{id:"ana-testing",children:"ANA Testing"}),"\n",(0,o.jsx)(n.p,{children:"The best example of \"Absolutely No Abstraction\" I've seen in testing is for ExpressJS route handlers. For you to understand what I mean when I say \"ANA is bad for testing\" I'm going to give you a typical test file and ask you to pretend you're going to maintain this codebase and these tests. It's important for you to understand how this route works. You're relieved that there are tests in place which will help you make sure you're not going to break something. So now you're going to use the tests to understand the nuances of the route handler."}),"\n",(0,o.jsx)(n.p,{children:"Try to read this test and understand the one nuance between the two of them."}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.p,{children:"Don't spend too long on this..."})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'import * as blogPostController from "../blog-post";\n\n// load the application-wide mock for the database.\n// I guess that means this is AANA (Almost Absolutely No Abstraction)\n// but I didn\'t want to write out a whole db mock for this blog post \ud83d\ude05\njest.mock("../../lib/db");\n\ntest("lists blog posts for the logged in user", async () => {\n  const req = {\n    locale: {\n      source: "default",\n      language: "en",\n      region: "GB",\n    },\n    user: {\n      guid: "0336397b-e29d-4b63-b94d-7e68a6fa3747",\n      isActive: false,\n      picture: "http://placehold.it/32x32",\n      age: 30,\n      name: {\n        first: "Francine",\n        last: "Oconnor",\n      },\n      company: "ACME",\n      email: "francine.oconnor@ac.me",\n      latitude: 51.507351,\n      longitude: -0.127758,\n      favoriteFruit: "banana",\n    },\n    body: {},\n    cookies: {},\n    query: {},\n    params: {\n      bucket: "photography",\n    },\n    header(name) {\n      return {\n        Authorization: "Bearer TEST_TOKEN",\n      }[name];\n    },\n  };\n  const res = {\n    clearCookie: jest.fn(),\n    cookie: jest.fn(),\n    end: jest.fn(),\n    locals: {\n      content: {},\n    },\n    json: jest.fn(),\n    send: jest.fn(),\n    sendStatus: jest.fn(),\n    set: jest.fn(),\n  };\n  const next = jest.fn();\n\n  await blogPostController.loadBlogPosts(req, res, next);\n\n  expect(res.json).toHaveBeenCalledTimes(1);\n  expect(res.json).toHaveBeenCalledWith({\n    posts: expect.arrayContaining([\n      expect.objectContaining({\n        title: "Test Post 1",\n        subtitle: "This is the subtitle of Test Post 1",\n        body: "This is the body of Test Post 1",\n      }),\n    ]),\n  });\n});\n\ntest("returns an empty list when there are no blog posts", async () => {\n  const req = {\n    locale: {\n      source: "default",\n      language: "en",\n      region: "GB",\n    },\n    user: {\n      guid: "0336397b-e29d-4b63-b94d-7e68a6fa3747",\n      isActive: false,\n      picture: "http://placehold.it/32x32",\n      age: 30,\n      name: {\n        first: "Francine",\n        last: "Oconnor",\n      },\n      company: "ACME",\n      email: "francine.oconnor@ac.me",\n      latitude: 31.230416,\n      longitude: 121.473701,\n      favoriteFruit: "banana",\n    },\n    body: {},\n    cookies: {},\n    query: {},\n    params: {\n      bucket: "photography",\n    },\n    header(name) {\n      return {\n        Authorization: "Bearer TEST_TOKEN",\n      }[name];\n    },\n  };\n  const res = {\n    clearCookie: jest.fn(),\n    cookie: jest.fn(),\n    end: jest.fn(),\n    locals: {\n      content: {},\n    },\n    json: jest.fn(),\n    send: jest.fn(),\n    sendStatus: jest.fn(),\n    set: jest.fn(),\n  };\n  const next = jest.fn();\n\n  await blogPostController.loadBlogPosts(req, res, next);\n\n  expect(res.json).toHaveBeenCalledTimes(1);\n  expect(res.json).toHaveBeenCalledWith({\n    posts: [],\n  });\n});\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Did you find the difference? Yeah! We expect to find a post in the first one and not in the second one! Cool! Great job. But... what causes that? Why does ",(0,o.jsx)(n.code,{children:"blogPostController.loadBlogPosts(req, res, next)"})," call res.json with a blog post in the first one and not in the second one?"]}),"\n",(0,o.jsx)(n.p,{children:"If you didn't figure that out, don't feel bad and don't worry, I'll show you later. If you did, you're probably really good at \"Where's Wally\" and that's my point. Tests like this make it harder than it needs to be to understand and maintain the tests."}),"\n",(0,o.jsx)(n.p,{children:"Now imagine that there are twenty such tests in a single file. You think it's terrible? Yes, it's pretty bad. Never seen tests like this before? You're lucky! I've seen it a lot. Here's how it gets this way:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Engineer Joe joins a team"}),"\n",(0,o.jsx)(n.li,{children:"Joe needs to add a test"}),"\n",(0,o.jsx)(n.li,{children:"Joe copies a previous test that looks like what they need and modifies it for their use case."}),"\n",(0,o.jsx)(n.li,{children:"Reviewers observe that the tests pass and assume Joe knows what they're talking about."}),"\n",(0,o.jsx)(n.li,{children:"PR is merged."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Here's your litmus test:"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"How easy is it to determine the difference between assertions of two similar tests and what causes that difference?"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Absolutely No Abstraction testing makes this very difficult."}),"\n",(0,o.jsx)(n.h2,{id:"dry-testing",children:"DRY Testing"}),"\n",(0,o.jsxs)(n.p,{children:["I don't have time at the moment to give you a good example of a ",(0,o.jsx)(n.code,{children:"DRY"})," test. Just know that often what happens when people apply ",(0,o.jsx)(n.code,{children:"DRY"})," to anything they typically wind up being harder to maintain due to this process:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Engineer Joe joins a team"}),"\n",(0,o.jsx)(n.li,{children:"Joe needs to add a test"}),"\n",(0,o.jsx)(n.li,{children:"Joes copies a previous test that looks basically exactly like what they need and adds another if statement to the 4. testing utility for their case."}),"\n",(0,o.jsx)(n.li,{children:"Reviewers observe that the tests pass and assume Joe knows what they're talking about."}),"\n",(0,o.jsx)(n.li,{children:"PR is merged."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Another thing that I see a lot in DRY testing is the overuse of ",(0,o.jsx)(n.code,{children:"describe"})," and ",(0,o.jsx)(n.code,{children:"it"})," nesting + ",(0,o.jsx)(n.code,{children:"beforeEach"}),". The more you nest and use shared variables between tests, the harder it is to follow the logic."]}),"\n",(0,o.jsx)(n.h2,{id:"aha-testing",children:"AHA Testing"}),"\n",(0,o.jsx)(n.p,{children:"That first test is absolutely screaming for abstraction (which is the guiding principle for AHA programming). So let's write a thoughtful abstraction for that test. Now try to figure out what makes the difference in these tests:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'import * as blogPostController from "../blog-post";\n\n// load the application-wide mock for the database.\njest.mock("../../lib/db");\n\nfunction setup(overrides = {}) {\n  const req = {\n    locale: {\n      source: "default",\n      language: "en",\n      region: "GB",\n    },\n    user: {\n      guid: "0336397b-e29d-4b63-b94d-7e68a6fa3747",\n      isActive: false,\n      picture: "http://placehold.it/32x32",\n      age: 30,\n      name: {\n        first: "Francine",\n        last: "Oconnor",\n      },\n      company: "ACME",\n      email: "francine.oconnor@ac.me",\n      latitude: 51.507351,\n      longitude: -0.127758,\n      favoriteFruit: "banana",\n    },\n    body: {},\n    cookies: {},\n    query: {},\n    params: {\n      bucket: "photography",\n    },\n    header(name) {\n      return {\n        Authorization: "Bearer TEST_TOKEN",\n      }[name];\n    },\n    ...overrides,\n  };\n\n  const res = {\n    clearCookie: jest.fn(),\n    cookie: jest.fn(),\n    end: jest.fn(),\n    locals: {\n      content: {},\n    },\n    json: jest.fn(),\n    send: jest.fn(),\n    sendStatus: jest.fn(),\n    set: jest.fn(),\n  };\n  const next = jest.fn();\n\n  return { req, res, next };\n}\n\ntest("lists blog posts for the logged in user", async () => {\n  const { req, res, next } = setup();\n\n  await blogPostController.loadBlogPosts(req, res, next);\n\n  expect(res.json).toHaveBeenCalledTimes(1);\n  expect(res.json).toHaveBeenCalledWith({\n    posts: expect.arrayContaining([\n      expect.objectContaining({\n        title: "Test Post 1",\n        subtitle: "This is the subtitle of Test Post 1",\n        body: "The is the body of Test Post 1",\n      }),\n    ]),\n  });\n});\n\ntest("returns an empty list when there are no blog posts", async () => {\n  const { req, res, next } = setup();\n  req.user.latitude = 31.230416;\n  req.user.longitude = 121.473701;\n\n  await blogPostController.loadBlogPosts(req, res, next);\n\n  expect(res.json).toHaveBeenCalledTimes(1);\n  expect(res.json).toHaveBeenCalledWith({\n    posts: [],\n  });\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"Now can you tell? What's the difference between the first and the second test? In the first our user is in London and in the second our user is in Shanghai! Gee, sure would've been nice if our co-workers had told us we were working on a location-based blogging platform (hey... now that's an interesting product idea \ud83e\udd14)."}),"\n",(0,o.jsx)(n.p,{children:"By adding just a little mindful abstraction, we've been able to make it much more clear what actually matters in the difference of the inputs and outputs leading to tests which make a LOT more sense and are WAY easier to maintain."}),"\n",(0,o.jsx)(n.h2,{id:"aha-testing-with-react",children:"AHA Testing with React"}),"\n",(0,o.jsx)(n.p,{children:"In a react world, I will sometimes have a renderFoo function that acts like the setup function here. Here's a simple example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'import * as React from "react";\nimport { render, screen } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport LoginForm from "../login-form";\n\nfunction renderLoginForm(props) {\n  render(<LoginForm {...props} />);\n  const usernameInput = screen.getByLabelText(/username/i);\n  const passwordInput = screen.getByLabelText(/password/i);\n  const submitButton = screen.getByText(/submit/i);\n  return {\n    usernameInput,\n    passwordInput,\n    submitButton,\n    changeUsername: (value) => userEvent.type(usernameInput, value),\n    changePassword: (value) => userEvent.type(passwordInput, value),\n    submitForm: () => userEvent.click(submitButton),\n  };\n}\n\ntest("submit calls the submit handler", () => {\n  const handleSubmit = jest.fn();\n  const { changeUsername, changePassword, submitForm } = renderLoginForm({\n    onSubmit: handleSubmit,\n  });\n  const username = "chucknorris";\n  const password = "ineednopassword";\n  changeUsername(username);\n  changePassword(password);\n  submitForm();\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n  expect(handleSubmit).toHaveBeenCalledWith({ username, password });\n});\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.p,{children:"I would consider this pre-mature abstraction if you've only got two or three tests in the file that is using it and those tests are short. But if you've got some nuance you're testing (like error states for example), then this kind of abstraction is great."})}),"\n",(0,o.jsx)(n.h2,{id:"nesting",children:"Nesting"}),"\n",(0,o.jsxs)(n.p,{children:["I'd recommend you give ",(0,o.jsx)(n.a,{href:"avoid-nesting-when-your-testing",children:"Avoid Nesting in Tests"})," a read."]}),"\n",(0,o.jsx)(n.h2,{id:"jest-in-case-and-testeach",children:"jest-in-case and test.each"}),"\n",(0,o.jsx)(n.p,{children:"If you're writing tests for a pure function, you're in luck because those are often the easiest to test for. You can seriously simplify your tests by using a simple abstraction that calls out VERY clearly the outputs and inputs."}),"\n",(0,o.jsx)(n.p,{children:"For (contrived) example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'import add from "../add";\n\ntest("adds one and two to equal three", () => {\n  expect(add(1, 2)).toBe(3);\n});\n\ntest("adds three and four to equal seven", () => {\n  expect(add(3, 4)).toBe(7);\n});\n\ntest("adds one hundred and two to equal one hundred two", () => {\n  expect(add(100, 2)).toBe(102);\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"That's pretty simple to follow, but it can be improved with jest-in-case:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'import cases from "jest-in-case";\nimport add from "../add";\n\ncases(\n  "add",\n  ({ first, second, result }) => {\n    expect(add(first, second)).toBe(result);\n  },\n  [\n    { first: 1, second: 2, result: 3 },\n    { first: 3, second: 4, result: 7 },\n    { first: 100, second: 2, result: 102 },\n  ]\n);\n'})}),"\n",(0,o.jsx)(n.p,{children:"I probably wouldn't bother doing this for this simple example, but what's cool about it is that you can add more test cases very easily by simply adding more elements to that array."}),"\n",(0,o.jsx)(n.p,{children:"This can also be applied to impure functions and modules as well, though it takes a little bit more work."}),"\n",(0,o.jsxs)(n.p,{children:["I personally prefer ",(0,o.jsx)(n.a,{href:"https://github.com/atlassian/jest-in-case",children:"jest-in-case"})," but Jest has a built-in ",(0,o.jsx)(n.code,{children:"test.each"})," functionality that you may find useful."]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:["Certainly our tests could've been improved by providing better names and/or comments as well, but our simple ",(0,o.jsx)(n.code,{children:"setup"})," abstraction (by the way, that's called a \"Test Object Factory\") doesn't really need them. So my point is: ",(0,o.jsx)(n.strong,{children:"it takes less work to write and maintain tests that have mindful abstractions applied to them."})]}),"\n",(0,o.jsx)(n.p,{children:"I hope that's helpful! Good luck!"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},3774:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(6672);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},4284:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/avoid-hasty-abstractions-testing-img1-e6fe74ee70bdae154aee77cd2c046827.png"}}]);