"use strict";(self.webpackChunkdeveloper_notes=self.webpackChunkdeveloper_notes||[]).push([[847],{3774:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(6672);const i={},a=o.createContext(i);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:t},e.children)}},5504:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>l,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"articles/avoid-hasty-abstractions-programming","title":"Avoid Hasty Abstractions Programming","description":"AUTHOR: Kent C. Dodds","source":"@site/docs/articles/avoid-hasty-abstractions-programming.md","sourceDirName":"articles","slug":"/articles/avoid-hasty-abstractions-programming","permalink":"/articles/avoid-hasty-abstractions-programming","draft":false,"unlisted":false,"editUrl":"https://github.com/samuelmaddox/samuelmaddox/blob/main/docs/articles/avoid-hasty-abstractions-programming.md","tags":[],"version":"current","lastUpdatedAt":1749129615000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"articlesSidebar","previous":{"title":"Avoid Nesting when You\'re Testing","permalink":"/articles/avoid-nesting-when-your-testing"},"next":{"title":"Testing Implementation Details","permalink":"/articles/testing-implementation-details"}}');var i=n(3420),a=n(3774);const s={sidebar_position:5},r="Avoid Hasty Abstractions Programming",d={},c=[{value:"DRY",id:"dry",level:2},{value:"WET",id:"wet",level:2},{value:"AHA \ud83d\udca1",id:"aha-",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"avoid-hasty-abstractions-programming",children:"Avoid Hasty Abstractions Programming"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"AUTHOR: Kent C. Dodds"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"POSTED: June 22nd, 2020"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.em,{children:["LINK: ",(0,i.jsx)(t.a,{href:"https://kentcdodds.com/blog/aha-programming",children:"https://kentcdodds.com/blog/aha-programming"})]})}),"\n",(0,i.jsx)(t.h2,{id:"dry",children:"DRY"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself",children:'DRY (an acronym for "Don\'t Repeat Yourself")'}),", is an old software principle that Wikipedia sums up like this:"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:'"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system"'}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["This is generally a good practice that I typically subscribe to (though less dogmatically than that definition seems to encourage). The biggest problem I've had with ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Duplicate_code",children:"code duplication"})," (aka copy/paste, it's basically the antithesis of DRY) is discovering a bug in one place, fixing it, then realizing that same bug was elsewhere and having to fix it there as well."]}),"\n",(0,i.jsx)(t.p,{children:"Once, I inherited a codebase that made very heavy use of code duplication and one time I had to fix a bug in eight different places! \ud83d\ude31 Talk about irritating! Abstracting that code into a function that could be called anywhere it was needed would've helped out a LOT."}),"\n",(0,i.jsx)(t.h2,{id:"wet",children:"WET"}),"\n",(0,i.jsx)(t.p,{children:"There's another concept that people have referred to as WET programming which stands for \"Write Everything Twice.\" That's similarly dogmatic and over prescriptive. Conlin Durbin has defined this as:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:'"You can ask yourself "Haven\'t I written this before?" two times, but never three."'}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In that same codebase I mentioned above, there was some over-abstraction that was even more harmful than duplication. It was AngularJS code and for several AngularJS controllers, the code passed ",(0,i.jsx)(t.code,{children:"this"})," to a function which would monkey-patch methods and properties onto ",(0,i.jsx)(t.code,{children:"this"})," in a way enhancing the controller instance with certain abilities. A sort of pseudo-inheritance thing I guess. It was SUPER confusing, hard to follow, and I was terrified to make any changes to that area of the codebase."]}),"\n",(0,i.jsx)(t.p,{children:"The code was reused in lots more than three places, but the abstraction was bad and I wished that the code had been duplicated instead."}),"\n",(0,i.jsx)(t.h2,{id:"aha-",children:"AHA \ud83d\udca1"}),"\n",(0,i.jsx)(t.p,{children:'AHA (pronounced "Aha!" like you just made a discovery) is an acronym I got from Cher Scarlett which stands for'}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"Avoid Hasty Abstractions"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The way I think of this principle is beautifully described by Sandi Metz who wrote:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:'"prefer duplication over the wrong abstraction"'}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Here's another important related principle that I want to add:"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:'"Optimize for change first"'}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"I think the key is that we don't know what the future of code will be. We could spend weeks optimizing code for performance, or coming up with the best API for our new abstraction, only to find out the next day that we made incorrect assumptions and the API needs a complete rework or the feature the code was written for is no longer needed. We don't know for sure. All we can really be sure of is that things will probably change, and if they never do then we wont touch the code anyway so who cares what it looks like?"}),"\n",(0,i.jsx)(t.p,{children:"Now, don't get me wrong, I'm not suggesting anarchy. I'm just suggesting that we should be mindful of the fact that we don't really know what requirements will be placed upon our code in the future."}),"\n",(0,i.jsx)(t.p,{children:"So I'm fine with code duplication until you feel pretty confident that you know the use cases for that duplicate code. What parts of the code are different that would make good arguments to your function? After you've got a few places where that code is running, the commonalities will scream at you for abstraction and you'll be in the right frame of mind to provide that abstraction."}),"\n",(0,i.jsx)(t.p,{children:"If you abstract early though, you'll think the function or component is perfect for your use case and so you just bend the code to fit your new use case. This goes on several times until the abstraction is basically your whole application in if statements and loops \ud83d\ude02\ud83d\ude2d"}),"\n",(0,i.jsx)(t.p,{children:"A few years ago, I was hired to review a company's codebase and I used a tool called jsinspect to identify chunks of copy/pasted code to show them opportunities for abstraction. They had a bunch of duplicated code and from my perspective looking in, it was obvious what the abstractions should look like."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"I think the big takeaway"})," about \"AHA Programming\" is that you shouldn't be dogmatic about when you start writing abstractions but instead write the abstraction when it feels right and don't be afraid to duplicate code until you get there."]}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(t.p,{children:["I feel like a measured and pragmatic approach to software principles is important. That's why I prefer ",(0,i.jsx)(t.code,{children:"AHA"})," over ",(0,i.jsx)(t.code,{children:"DRY"})," or ",(0,i.jsx)(t.code,{children:"WET"}),". It's intended to help you be mindful of your abstractions without giving hard-fast rules to when it is or isn't ok to abstract some code into a function or module."]}),"\n",(0,i.jsx)(t.p,{children:"I hope that's helpful to you. Good luck!"})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);