"use strict";(self.webpackChunkdeveloper_notes=self.webpackChunkdeveloper_notes||[]).push([[32],{3774:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(6672);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},7970:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"articles/testing-implementation-details","title":"Testing Implementation Details","description":"AUTHOR: Kent C. Dodds","source":"@site/docs/articles/testing-implementation-details.md","sourceDirName":"articles","slug":"/articles/testing-implementation-details","permalink":"/articles/testing-implementation-details","draft":false,"unlisted":false,"editUrl":"https://github.com/samuelmaddox/samuelmaddox/blob/main/docs/articles/testing-implementation-details.md","tags":[],"version":"current","lastUpdatedAt":1749129615000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"articlesSidebar","previous":{"title":"Avoid Hasty Abstractions Programming","permalink":"/articles/avoid-hasty-abstractions-programming"},"next":{"title":"Why You Should Use String Literal Unions Over Enums in TypeScript","permalink":"/articles/why-you-should-use-string-literal-unions-over-enums-in-typescript/"}}');var o=n(3420),i=n(3774);const a={sidebar_position:6},r="Testing Implementation Details",l={},d=[{value:"Why is testing implementation details bad?",id:"why-is-testing-implementation-details-bad",level:2},{value:"False negatives when refactoring",id:"false-negatives-when-refactoring",level:2},{value:"False positives",id:"false-positives",level:2},{value:"Implementation detail free testing",id:"implementation-detail-free-testing",level:2},{value:"So... What are implementation details then?",id:"so-what-are-implementation-details-then",level:2},{value:"So, what about hooks",id:"so-what-about-hooks",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"testing-implementation-details",children:"Testing Implementation Details"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"AUTHOR: Kent C. Dodds"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"POSTED: August 17th, 2020"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsxs)(t.em,{children:["LINK: ",(0,o.jsx)(t.a,{href:"https://kentcdodds.com/blog/testing-implementation-details",children:"https://kentcdodds.com/blog/testing-implementation-details"})]})}),"\n",(0,o.jsxs)(t.p,{children:["Back when I was using enzyme (like everyone else at the time), I stepped carefully around certainAPIs in enzyme. I ",(0,o.jsx)(t.strong,{children:"completely avoided shallow rendering"}),", ",(0,o.jsx)(t.em,{children:"never"})," used APIs like ",(0,o.jsx)(t.code,{children:"instance()"}),", ",(0,o.jsx)(t.code,{children:"state()"}),", or ",(0,o.jsx)(t.code,{children:"find('ComponentName')"}),". And in code reviews of other people's pull requests I explained again and again why it's important to avoid these APIs. The reason is they each allow your test to test implementation details of your components. People often ask me what I mean by\"implementation details.\" I mean, it's hard enough to test as it is! Why do we have to make all these rules to make it harder?"]}),"\n",(0,o.jsx)(t.h2,{id:"why-is-testing-implementation-details-bad",children:"Why is testing implementation details bad?"}),"\n",(0,o.jsx)(t.p,{children:"There are two distinct and important reasons to avoid testing implementation details. Tests which test implementation details:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Can break when you refactor application code. ",(0,o.jsx)(t.strong,{children:"False negatives"})]}),"\n",(0,o.jsxs)(t.li,{children:["May not fail when you break application code. ",(0,o.jsx)(t.strong,{children:"False positives"})]}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:'To be clear, the test is: "does the software work". If the test passes, then that means the test came back "positive" (found working software). If it does not, that means the test comes back "negative" (did not find working software). The term "False" refers to when the test came back with an incorrect result, meaning the software is actually broken but the test passes (false positive) or the software is actually working but the test fails (false negative).'}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Let's take a look at each of these in turn, using the following simple accordion component as an example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'import * as React from "react";\nimport AccordionContents from "./accordion-contents";\n\nclass Accordion extends React.Component {\n  state = { openIndex: 0 };\n  setOpenIndex = (openIndex) => this.setState({ openIndex });\n  render() {\n    const { openIndex } = this.state;\n    return (\n      <div>\n        {this.props.items.map((item, index) => (\n          <>\n            <button onClick={() => this.setOpenIndex(index)}>\n              {item.title}\n            </button>\n            {index === openIndex ? (\n              <AccordionContents>{item.contents}</AccordionContents>\n            ) : null}\n          </>\n        ))}\n      </div>\n    );\n  }\n}\n\nexport default Accordion;\n'})}),"\n",(0,o.jsx)(t.p,{children:"If you're wondering why I'm using a dated class component and not modern function component (with hooks) for these examples, keep reading, it's an interesting reveal (which some of those of you experienced with enzyme you might already be expecting)."}),"\n",(0,o.jsx)(t.p,{children:"And here's a test that tests implementation details:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'// __tests__/accordion.enzyme.js 1\nimport * as React from "react";\n// if you\'re wondering why not shallow,\n// then please read https://kcd.im/shallow\nimport Enzyme, { mount } from "enzyme";\nimport EnzymeAdapter from "enzyme-adapter-react-16";\nimport Accordion from "../accordion";\n\n// Setup enzyme\'s react adapter 9\nEnzyme.configure({ adapter: new EnzymeAdapter() });\n\ntest("setOpenIndex sets the open index state properly", () => {\n  const wrapper = mount(<Accordion items={[]} />);\n  expect(wrapper.state("openIndex")).toBe(0);\n  wrapper.instance().setOpenIndex(1);\n  expect(wrapper.state("openIndex")).toBe(1);\n});\n\ntest("Accordion renders AccordionContents with the item contents", () => {\n  const hats = { title: "Favorite Hats", contents: "Fedoras are classy" };\n  const footware = {\n    title: "Favorite Footware",\n    contents: "Flipflops are the best",\n  };\n  const wrapper = mount(<Accordion items={[hats, footware]} />);\n  expect(wrapper.find("AccordionContents").props().children).toBe(\n    hats.contents\n  );\n});\n'})}),"\n",(0,o.jsx)(t.p,{children:"Raise your hand if you've seen (or written) tests like this in your codebase (\ud83d\ude4c)."}),"\n",(0,o.jsx)(t.p,{children:"Ok, now let's take a look at how things break down with these tests..."}),"\n",(0,o.jsx)(t.h2,{id:"false-negatives-when-refactoring",children:"False negatives when refactoring"}),"\n",(0,o.jsx)(t.p,{children:'A surprising number of people find testing distasteful, especially UI testing. Why is this? There are various reasons for it, but one big reason I hear again and again is that people spend way too much time babysitting the tests. "Every time I make a change to the code, the tests break!" This is areal drag on productivity! Let\'s see how our tests fall prey to this frustrating problem.'}),"\n",(0,o.jsxs)(t.p,{children:["Let's say I come in and I'm refactoring this accordion to prepare it to allow for multiple accordion items to be open at once. A refactor doesn't change existing behavior at all, it just changes the ",(0,o.jsx)(t.strong,{children:"implementation"}),". So let's change the ",(0,o.jsx)(t.strong,{children:"implementation"})," in a way that doesn't change the behavior."]}),"\n",(0,o.jsxs)(t.p,{children:["Let's say that we're working on adding the ability for multiple accordion elements to be opened at once, so we're changing our internal state from ",(0,o.jsx)(t.code,{children:"openIndex"})," to ",(0,o.jsx)(t.code,{children:"openIndexes"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:"class Accordion extends React.Component {\n  state = { openIndexes: [0] };\n  setOpenIndex = (openIndex) => this.setState({ openIndexes: [openIndex] });\n  render() {\n    const { openIndexes } = this.state;\n    return (\n      <div>\n        {this.props.items.map((item, index) => (\n          <>\n            <button onClick={() => this.setOpenIndex(index)}>\n              {item.title}\n            </button>\n            {openIndexes.includes(index) ? (\n              <AccordionContents>{item.contents}</AccordionContents>\n            ) : null}\n          </>\n        ))}\n      </div>\n    );\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Awesome, we do a quick check in the app and everything's still working properly, so when wecome to this component later to support opening multiple accordions, it'll be a cinch! Then we runthe tests and \ud83d\udca5kaboom\ud83d\udca5 they're busted. Which one broke? ",(0,o.jsx)(t.code,{children:"setOpenIndex"})," sets the open index state properly."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-terminal",children:"expect(received).toBe(expected)\n\nExpected value to be (using ===):\n  0\nReceived:\n  undefined\n"})}),"\n",(0,o.jsx)(t.p,{children:"Is that test failure warning us of a real problem? Nope! The component still works fine."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"This is what's called a false negative."})," It means that we got a test failure, but it was because of a broken test, not broken app code. I honestly cannot think of a more annoying test failure situation. Oh well, let's go ahead and fix our test:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'test("setOpenIndex sets the open index state properly", () => {\n  const wrapper = mount(<Accordion items={[]} />);\n  expect(wrapper.state("openIndexes")).toEqual([0]);\n  wrapper.instance().setOpenIndex(1);\n  expect(wrapper.state("openIndexes")).toEqual([1]);\n});\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The takeaway: ",(0,o.jsx)(t.strong,{children:"Tests which test implementation details can give you a false negative when you refactor your code. This leads to brittle and frustrating tests that seem to break anytime you so much as look at the code."})]}),"\n",(0,o.jsx)(t.h2,{id:"false-positives",children:"False positives"}),"\n",(0,o.jsx)(t.p,{children:"Ok, so now let's say your co-worker is working in the Accordion and they see this code:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:"<button onClick={() => this.setOpenIndex(index)}>{item.title}</button>\n"})}),"\n",(0,o.jsxs)(t.p,{children:['Immediately their premature performance optimization feelings kick in and they say to themselves, "hey! inline arrow functions in ',(0,o.jsx)(t.code,{children:"render"})," are ",(0,o.jsx)(t.strong,{children:"bad for performance"}),", so I'll just clean that up! I think this should work, I'll just change it really quick and run tests.\""]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:"<button onClick={this.setOpenIndex}>{item.title}</button>\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Cool. Run the tests and... \u2705\u2705 awesome! They commit the code without checking it in the browser because tests give confidence right? That commit goes in a completely unrelated PR that changes thousands of lines of code and is understandably missed. The accordion breaks in production and Nancy is unable to get her tickets to see ",(0,o.jsx)(t.strong,{children:"Wicked in Salt Lake next February"}),". Nancy is crying and your team feels horrible."]}),"\n",(0,o.jsxs)(t.p,{children:["So what went wrong? Didn't we have a test to verify that the state changes when ",(0,o.jsx)(t.code,{children:"setOpenIndex"})," is called and that the accordion contents are displayed appropriately!? Yes you did! But the problem is that there was no test to verify that the button was wired up to ",(0,o.jsx)(t.code,{children:"setOpenIndex"})," correctly."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"This is called a false positive."})," It means that we didn't get a test failure, but we should have! So how do we cover ourselves to make sure this doesn't happen again? We need to add another test to verify clicking the button updates the state correctly. And then I need to add a coverage threshold of 100% code coverage so we don't make this mistake again. Oh, and I should write a dozen or so ESLint plugins to make sure people don't use these APIs that encourage testing implementation details!"]}),"\n",(0,o.jsxs)(t.p,{children:["... But I'm not going to bother... Ugh, I'm just so tired of all these false positives and negatives, I'd almost rather not write tests at all. DELETE ALL THE TESTS! Wouldn't it be nice if we had a tool that had a wider ",(0,o.jsx)(t.strong,{children:"pit of success"}),"? Yes it would! And guess what, we DO have such a tool!"]}),"\n",(0,o.jsx)(t.h2,{id:"implementation-detail-free-testing",children:"Implementation detail free testing"}),"\n",(0,o.jsxs)(t.p,{children:["So we could rewrite all these tests with enzyme, limiting ourselves to APIs that are free of implementation details, but instead, I'm just going to use ",(0,o.jsx)(t.strong,{children:"React Testing Library"})," which will make it very difficult to include implementation details in my tests. Let's check that out now!"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:'// __tests__/accordion.rtl.js\nimport "@testing-library/jest-dom/extend-expect";\nimport * as React from "react";\nimport { render, screen } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport Accordion from "../accordion";\n\ntest("can open accordion items to see the contents", () => {\n  const hats = { title: "Favorite Hats", contents: "Fedoras are classy" };\n  const footware = {\n    title: "Favorite Footware",\n    contents: "Flipflops are the best",\n  };\n  render(<Accordion items={[hats, footware]} />);\n\n  expect(screen.getByText(hats.contents)).toBeInTheDocument();\n  expect(screen.queryByText(footware.contents)).not.toBeInTheDocument();\n\n  userEvent.click(screen.getByText(footware.title));\n\n  expect(screen.getByText(footware.contents)).toBeInTheDocument();\n  expect(screen.queryByText(hats.contents)).not.toBeInTheDocument();\n});\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Sweet! A single test that verifies all the behavior really well. And this test passes whether my state is called ",(0,o.jsx)(t.code,{children:"openIndex"}),", ",(0,o.jsx)(t.code,{children:"openIndexes"}),", or ",(0,o.jsx)(t.code,{children:"tacosAreTasty"})," \ud83c\udf2e. Nice! Got rid of that false negative! And if I wire up my click handler incorrectly, this test will fail. Sweet, got rid of that false positive too! And I didn't have to memorize any list of rules. I just use the tool in the idiomatic usage, and I get a test that actually can give me confidence my accordion is working as the user wants it too."]}),"\n",(0,o.jsx)(t.h2,{id:"so-what-are-implementation-details-then",children:"So... What are implementation details then?"}),"\n",(0,o.jsx)(t.p,{children:"Here's the simplest definition I can come up with:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Implementation details are things which users of your code will not typically use, see, or even know about."})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:['So the first question we need an answer to is: "Who is the user of this code." Well, the end user who will be interacting with our component in the browser is definitely a user. They\'ll be observing and interacting with the rendered buttons and contents. But we also have the developer who will be rendering the accordion with props (in our case, a given list of items). So React components typically have two users: end-users, and developers. ',(0,o.jsx)(t.strong,{children:'End-users and developers are the two "users" that our application code needs to consider.'})]}),"\n",(0,o.jsxs)(t.p,{children:["Great, so what parts of our code do each of these users use, see, and know about? The end user will see/interact with what we render in the ",(0,o.jsx)(t.code,{children:"render"})," method. The developer will see/interact with the props they pass to the component. So our test should typically only see/interact with the props that are passed, and the rendered output."]}),"\n",(0,o.jsxs)(t.p,{children:["This is precisely what the ",(0,o.jsx)(t.strong,{children:"React Testing Library"})," test does. We give it our own React element of the Accordion component with our fake props, then we interact with the rendered output by querying the output for the contents that will be displayed to the user (or ensuring that it wont be displayed) and clicking the buttons that are rendered."]}),"\n",(0,o.jsxs)(t.p,{children:["Now consider the enzyme test. With enzyme, we access the ",(0,o.jsx)(t.code,{children:"state"})," of ",(0,o.jsx)(t.code,{children:"openIndex"}),". This is not something that either of our users care about directly. They don't know that's what it's called, they don't know whether the open index is stored as a single primitive value, or stored as an array, and frankly they don't care. They also don't know or care about the ",(0,o.jsx)(t.code,{children:"setOpenIndex"})," method specifically. And yet, our test knows about both of these implementation details."]}),"\n",(0,o.jsxs)(t.p,{children:["This is what makes our enzyme test prone to false negatives. Because ",(0,o.jsx)(t.strong,{children:"by making our test use the component differently than end-users and developers do, we create a third user our application code needs to consider: the tests!"})," And frankly, the tests are one user that nobody cares about. I don't want my application code to consider the tests. What a complete waste of time. I don't want tests that are written for their own sake. ",(0,o.jsx)(t.em,{children:"Automated tests should verify that the application code works for the production users."})]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:'"The more your tests resemble the way your software is used, the more confidence they can give you."'})," \u200a\u2014\u200ame"]}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["Read more about this in ",(0,o.jsx)(t.a,{href:"avoid-the-test-user",children:"Avoid the Test User"})]})}),"\n",(0,o.jsx)(t.h2,{id:"so-what-about-hooks",children:"So, what about hooks"}),"\n",(0,o.jsxs)(t.p,{children:["Well, as it turns out, ",(0,o.jsx)(t.strong,{children:"enzyme still has a lot of trouble with hooks"}),". Turns out when you're testing implementation details, a change in the implementation has a big impact on your tests. This is a big bummer because if you're migrating class components to function components with hooks, then your tests can't help you know that you didn't break anything in the process."]}),"\n",(0,o.jsx)(t.p,{children:"React Testing Library on the other hand? It works either way. I like to call tests you write with React Testing Library:"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Implementation detail free and refactor friendly."})}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"So how do you avoid testing implementation details? Using the right tools is a good start. Here's a process for how to know what to test. Following this process helps you have the right mindset when testing and you will naturally avoid implementation details:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"What part of your untested codebase would be really bad if it broke? (The checkout process)"}),"\n",(0,o.jsx)(t.li,{children:'Try to narrow it down to a unit or a few units of code (When clicking the "checkout" button a request with the cart items is sent to /checkout)'}),"\n",(0,o.jsx)(t.li,{children:'Look at that code and consider who the "users" are (The developer rendering the checkout form, the end user clicking on the button)'}),"\n",(0,o.jsx)(t.li,{children:"Write down a list of instructions for that user to manually test that code to make sure it's not broken. (render the form with some fake data in the cart, click the checkout button, ensure the mocked /checkout API was called with the right data, respond with a fake successful response, make sure the success message is displayed)."}),"\n",(0,o.jsx)(t.li,{children:"Turn that list of instructions into an automated test."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);