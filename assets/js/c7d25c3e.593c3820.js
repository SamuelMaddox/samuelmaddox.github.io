"use strict";(self.webpackChunkdeveloper_notes=self.webpackChunkdeveloper_notes||[]).push([[687],{710:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"articles/avoid-nesting-when-your-testing","title":"Avoid Nesting when You\'re Testing","description":"AUTHOR: Kent C. Dodds","source":"@site/docs/articles/avoid-nesting-when-your-testing.md","sourceDirName":"articles","slug":"/articles/avoid-nesting-when-your-testing","permalink":"/articles/avoid-nesting-when-your-testing","draft":false,"unlisted":false,"editUrl":"https://github.com/samuelmaddox/samuelmaddox/blob/main/docs/articles/avoid-nesting-when-your-testing.md","tags":[],"version":"current","lastUpdatedAt":1749129615000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"articlesSidebar","previous":{"title":"Avoid the Test User","permalink":"/articles/avoid-the-test-user/"},"next":{"title":"Avoid Hasty Abstractions Programming","permalink":"/articles/avoid-hasty-abstractions-programming"}}');var i=t(3420),r=t(3774);const a={sidebar_position:4},o="Avoid Nesting when You're Testing",l={},c=[{value:"Over-abstraction",id:"over-abstraction",level:2},{value:"Nesting",id:"nesting",level:2},{value:"Inline it!",id:"inline-it",level:2},{value:"Apply AHA (Avoid Hasty Abstractions)",id:"apply-aha-avoid-hasty-abstractions",level:2},{value:"What about grouping tests?",id:"what-about-grouping-tests",level:2},{value:"What about cleanup?",id:"what-about-cleanup",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"avoid-nesting-when-youre-testing",children:"Avoid Nesting when You're Testing"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"AUTHOR: Kent C. Dodds"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"POSTED: July 29th, 2019"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["LINK: ",(0,i.jsx)(n.a,{href:"https://kentcdodds.com/blog/avoid-nesting-when-youre-testing",children:"https://kentcdodds.com/blog/avoid-nesting-when-youre-testing"})]})}),"\n",(0,i.jsx)(n.p,{children:"I want to show you something. What I'm going to show is a general testing principle, applied to a React component test. So even though the example is a React one, hopefully it helps communicate the concept properly."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["My point isn't that nesting is bad by itself, but rather that it naturally encourages using test hooks (such as ",(0,i.jsx)(n.code,{children:"beforeEach"}),") as a mechanism for code reuse which does lead to unmaintainable tests. Please read on..."]})}),"\n",(0,i.jsx)(n.p,{children:"Here's a React component that I want to test:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'// login.js\nimport * as React from "react";\n\nfunction Login({ onSubmit }) {\n  const [error, setError] = React.useState("");\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    const {\n      usernameInput: { value: username },\n      passwordInput: { value: password },\n    } = event.target.elements;\n\n    if (!username) {\n      setError("username is required");\n    } else if (!password) {\n      setError("password is required");\n    } else {\n      setError("");\n      onSubmit({ username, password });\n    }\n  }\n\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label htmlFor="usernameInput">Username</label>\n          <input id="usernameInput" />\n        </div>\n        <div>\n          <label htmlFor="passwordInput">Password</label>\n          <input id="passwordInput" type="password" />\n        </div>\n        <button type="submit">Submit</button>\n      </form>\n      {error ? <div role="alert">{error}</div> : null}\n    </div>\n  );\n}\n\nexport default Login;\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here's a test suite that resembles the kind of testing I've seen over the years."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'// __tests__/login.js\nimport { render } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport * as React from "react";\n\nimport Login from "../login";\n\ndescribe("Login", () => {\n  let utils,\n    handleSubmit,\n    user,\n    changeUsernameInput,\n    changePasswordInput,\n    clickSubmit;\n\n  beforeEach(() => {\n    handleSubmit = jest.fn();\n    user = { username: "michelle", password: "smith" };\n    utils = render(<Login onSubmit={handleSubmit} />);\n    changeUsernameInput = (value) =>\n      userEvent.type(utils.getByLabelText(/username/i), value);\n    changePasswordInput = (value) =>\n      userEvent.type(utils.getByLabelText(/password/i), value);\n    clickSubmit = () => userEvent.click(utils.getByText(/submit/i));\n  });\n\n  describe("when username and password is provided", () => {\n    beforeEach(() => {\n      changeUsernameInput(user.username);\n      changePasswordInput(user.password);\n    });\n\n    describe("when the submit button is clicked", () => {\n      beforeEach(() => {\n        clickSubmit();\n      });\n\n      it("should call onSubmit with the username and password", () => {\n        expect(handleSubmit).toHaveBeenCalledTimes(1);\n        expect(handleSubmit).toHaveBeenCalledWith(user);\n      });\n    });\n  });\n\n  describe("when the password is not provided", () => {\n    beforeEach(() => {\n      changeUsernameInput(user.username);\n    });\n\n    describe("when the submit button is clicked", () => {\n      let errorMessage;\n      beforeEach(() => {\n        clickSubmit();\n        errorMessage = utils.getByRole("alert");\n      });\n\n      it("should show an error message", () => {\n        expect(errorMessage).toHaveTextContent(/password is required/i);\n      });\n    });\n  });\n\n  describe("when the username is not provided", () => {\n    beforeEach(() => {\n      changePasswordInput(user.password);\n    });\n\n    describe("when the submit button is clicked", () => {\n      let errorMessage;\n      beforeEach(() => {\n        clickSubmit();\n        errorMessage = utils.getByRole("alert");\n      });\n\n      it("should show an error message", () => {\n        expect(errorMessage).toHaveTextContent(/username is required/i);\n      });\n    });\n  });\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"That should give us 100% confidence that this component works and will continue to work as designed. And it does. But here are the things I don't like about that test:"}),"\n",(0,i.jsx)(n.h2,{id:"over-abstraction",children:"Over-abstraction"}),"\n",(0,i.jsxs)(n.p,{children:["I feel like the utilities like ",(0,i.jsx)(n.code,{children:"changeUsernameInput"})," and ",(0,i.jsx)(n.code,{children:"clickSubmit"})," can be nice, but the tests are simple enough that duplicating that code instead could simplify our test code a bit. It's just that the abstraction of the function doesn't really give us a whole lot of benefit for this small set of tests, and we incur the cost for maintainers to have to look around the file for where those functions are defined."]}),"\n",(0,i.jsx)(n.h2,{id:"nesting",children:"Nesting"}),"\n",(0,i.jsxs)(n.p,{children:["The tests above are written with Jest APIs, but you'll find similar APIs in all major JavaScript frameworks. I'm talking specifically about ",(0,i.jsx)(n.code,{children:"describe"})," which is used for grouping tests, ",(0,i.jsx)(n.code,{children:"beforeEach"})," for common setup/actions, and ",(0,i.jsx)(n.code,{children:"it"})," for the actual assertions."]}),"\n",(0,i.jsx)(n.p,{children:"I have a strong dislike for nesting like this. I've written and maintained thousands of tests that were written like this and I can tell you that as painful as it is for these three simple tests, it's way worse when you have thousands of lines of tests and wind up nesting even further."}),"\n",(0,i.jsx)(n.p,{children:"What makes it so complex? Take this bit for example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'it("should call onSubmit with the username and password", () => {\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n  expect(handleSubmit).toHaveBeenCalledWith(user);\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Where is handleSubmit coming from and what's its value? Where is user coming from? What's its value? Oh sure, you can go find where it's defined:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'describe("Login", () => {\n  let utils,\n    handleSubmit,\n    user,\n    changeUsernameInput,\n    changePasswordInput,\n    clickSubmit;\n  // ...\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"But then you also have to figure out where it's assigned:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'beforeEach(() => {\n  handleSubmit = jest.fn();\n  user = { username: "michelle", password: "smith" };\n  // ...\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["And then, you have to make sure that it's not actually being assigned to something else in a further nested ",(0,i.jsx)(n.code,{children:"beforeEach"}),". Tracing through the code to keep track of the variables and their values over time is the number one reason I strongly recommend against nested tests. The more you have to hold in your head for menial things like that, the less room there is for accomplishing the important task at hand."]}),"\n",(0,i.jsx)(n.p,{children:'You can argue that variable reassignment is an "anti-pattern" and should be avoided, and I would agree with you, but adding more linting rules to your suite of possibly already overbearing linting rules is not an awesome solution. What if there were a way to share this common setup without having to worry about variable reassignment at all?'}),"\n",(0,i.jsx)(n.h2,{id:"inline-it",children:"Inline it!"}),"\n",(0,i.jsx)(n.p,{children:"For this simple component, I think the best solution is to just remove as much abstraction as possible. Check this out:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'// __tests__/login.js\nimport { render } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport * as React from "react";\n\nimport Login from "../login";\n\ntest("calls onSubmit with the username and password when submit is clicked", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText, getByText } = render(\n    <Login onSubmit={handleSubmit} />\n  );\n  const user = { username: "michelle", password: "smith" };\n\n  userEvent.type(getByLabelText(/username/i), user.username);\n  userEvent.type(getByLabelText(/password/i), user.password);\n  userEvent.click(getByText(/submit/i));\n\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n  expect(handleSubmit).toHaveBeenCalledWith(user);\n});\n\ntest("shows an error message when submit is clicked and no username is provided", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText, getByText, getByRole } = render(\n    <Login onSubmit={handleSubmit} />\n  );\n\n  userEvent.type(getByLabelText(/password/i), "anything");\n  userEvent.click(getByText(/submit/i));\n\n  const errorMessage = getByRole("alert");\n  expect(errorMessage).toHaveTextContent(/username is required/i);\n  expect(handleSubmit).not.toHaveBeenCalled();\n});\n\ntest("shows an error message when submit is clicked and no password is provided", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText, getByText, getByRole } = render(\n    <Login onSubmit={handleSubmit} />\n  );\n\n  userEvent.type(getByLabelText(/username/i), "anything");\n  userEvent.click(getByText(/submit/i));\n\n  const errorMessage = getByRole("alert");\n  expect(errorMessage).toHaveTextContent(/password is required/i);\n  expect(handleSubmit).not.toHaveBeenCalled();\n});\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"test"})," is an alias for ",(0,i.jsx)(n.code,{children:"it"})," and I just prefer using ",(0,i.jsx)(n.code,{children:"test"})," when I'm not nested in a ",(0,i.jsx)(n.code,{children:"describe"}),"."]})}),"\n",(0,i.jsx)(n.p,{children:"You'll notice that there is a bit of duplication there (we'll get to that), but look at how clear these tests are. With the exception of some test utilities and the Login component itself, the entire test is self-contained. This significantly improves the ability for us to understand what's going on in each test without having to do any scrolling around. If this component had a few dozen more tests, the benefits would be even more potent."}),"\n",(0,i.jsxs)(n.p,{children:["Notice also that we aren't nesting everything in a ",(0,i.jsx)(n.code,{children:"describe"})," block, because it's really not necessary. Everything in the file is clearly testing the ",(0,i.jsx)(n.code,{children:"login"})," component, and including even a single level of nesting is pointless."]}),"\n",(0,i.jsx)(n.h2,{id:"apply-aha-avoid-hasty-abstractions",children:"Apply AHA (Avoid Hasty Abstractions)"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"avoid-hasty-abstractions-programming",children:"AHA principle"})," states that you should:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:'"prefer duplication over the wrong abstraction and optimize for change first."'})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For our simple Login component here, I'd probably leave the test as-is, but let's imagine that it's a bit more complicated and we're starting to see some problems with code duplication and we'd like to reduce it. Should we reach for ",(0,i.jsx)(n.code,{children:"beforeEach"})," for that? I mean, that's what it's there for right?"]}),"\n",(0,i.jsx)(n.p,{children:"Well, we could, but then we have to start worrying about mutable variable assignments again and we'd like to avoid that. How else could we share code between our tests? AHA! We could use functions!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { render } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport * as React from "react";\n\nimport Login from "../login";\n\n// here we have a bunch of setup functions that compose together for our test cases\n// I only recommend doing this when you have a lot of tests that do the same thing.\n// I\'m including it here only as an example. These tests don\'t necessitate this\n// much abstraction. Read more: https://kcd.im/aha-testing\nfunction setup() {\n  const handleSubmit = jest.fn();\n  const utils = render(<Login onSubmit={handleSubmit} />);\n  const user = { username: "michelle", password: "smith" };\n  const changeUsernameInput = (value) =>\n    userEvent.type(utils.getByLabelText(/username/i), value);\n  const changePasswordInput = (value) =>\n    userEvent.type(utils.getByLabelText(/password/i), value);\n  const clickSubmit = () => userEvent.click(utils.getByText(/submit/i));\n  return {\n    ...utils,\n    handleSubmit,\n    user,\n    changeUsernameInput,\n    changePasswordInput,\n    clickSubmit,\n  };\n}\n\nfunction setupSuccessCase() {\n  const utils = setup();\n  utils.changeUsernameInput(utils.user.username);\n  utils.changePasswordInput(utils.user.password);\n  utils.clickSubmit();\n  return utils;\n}\n\nfunction setupWithNoPassword() {\n  const utils = setup();\n  utils.changeUsernameInput(utils.user.username);\n  utils.clickSubmit();\n  const errorMessage = utils.getByRole("alert");\n  return { ...utils, errorMessage };\n}\n\nfunction setupWithNoUsername() {\n  const utils = setup();\n  utils.changePasswordInput(utils.user.password);\n  utils.clickSubmit();\n  const errorMessage = utils.getByRole("alert");\n  return { ...utils, errorMessage };\n}\n\ntest("calls onSubmit with the username and password", () => {\n  const { handleSubmit, user } = setupSuccessCase();\n  expect(handleSubmit).toHaveBeenCalledTimes(1);\n  expect(handleSubmit).toHaveBeenCalledWith(user);\n});\n\ntest("shows an error message when submit is clicked and no username is provided", () => {\n  const { handleSubmit, errorMessage } = setupWithNoUsername();\n  expect(errorMessage).toHaveTextContent(/username is required/i);\n  expect(handleSubmit).not.toHaveBeenCalled();\n});\n\ntest("shows an error message when password is not provided", () => {\n  const { handleSubmit, errorMessage } = setupWithNoPassword();\n  expect(errorMessage).toHaveTextContent(/password is required/i);\n  expect(handleSubmit).not.toHaveBeenCalled();\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Now we could have dozens of tests that use these simple ",(0,i.jsx)(n.code,{children:"setup"})," functions, and notice also that they can be composed together to give us a similar behavior as the nested ",(0,i.jsx)(n.code,{children:"beforeEach"})," that we had before if that makes sense. But we avoid having mutable variables that we have to worry about keeping track of in our mind."]}),"\n",(0,i.jsxs)(n.p,{children:["You can learn more about the benefits of AHA with testing from ",(0,i.jsx)(n.a,{href:"avoid-hasty-abstractions-testing",children:"AHA Testing"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"what-about-grouping-tests",children:"What about grouping tests?"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"describe"})," function is intended to group related tests together and can provide for a nice way to visually separate different tests, especially when the test file gets big. But I don't like it when the test file gets big. So instead of grouping tests by ",(0,i.jsx)(n.code,{children:"describe"})," blocks, I group them by file. So if there's a logical grouping of different tests for the same \"unit\" of code, I'll separate them by putting them in completely different files. And if there's some code that really needs to be shared between them, then I'll create a ",(0,i.jsx)(n.code,{children:"__tests__/helpers/login.js"})," file which has the shared code."]}),"\n",(0,i.jsx)(n.p,{children:"This comes with the benefit of logically grouping tests, completely separating any setup that's unique for them, reducing the cognitive load of working on a particular part of the unit of code I'm working on, and if your testing framework can run tests in parallel, then my tests will probably run faster as well."}),"\n",(0,i.jsx)(n.h2,{id:"what-about-cleanup",children:"What about cleanup?"}),"\n",(0,i.jsxs)(n.p,{children:["This blog post isn't an attack on utilities like ",(0,i.jsx)(n.code,{children:"beforeEach"}),"/",(0,i.jsx)(n.code,{children:"afterEach"}),"/etc. It's more of a caution against mutable variables in tests, and being mindful of your abstractions."]}),"\n",(0,i.jsx)(n.p,{children:"For cleanup, sometimes you're stuck with a situation where the thing you're testing makes some changes to the global environment and you need to cleanup after it. If you try to put that code inline within your test, then a test failure would result in your cleanup not running which could then lead to other tests failing, ultimately resulting in a lot of error output that is harder to debug."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["This example was written before ",(0,i.jsx)(n.code,{children:"@testing-library/react@9"})," which made cleanup automatic. But the concept still applies and I didn't want to rewrite the example \ud83d\ude05"]})}),"\n",(0,i.jsx)(n.p,{children:"For example, React Testing Library will insert your component into the document, and if you don't cleanup after each test, then your tests can run over themselves:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { render } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport * as React from "react";\n\nimport Login from "../login";\n\ntest("example 1", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText } = render(<Login onSubmit={handleSubmit} />);\n  userEvent.type(getByLabelText(/username/i), "kentcdodds");\n  userEvent.type(getByLabelText(/password/i), "ilovetwix");\n  // more test here\n});\n\ntest("example 2", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText } = render(<Login onSubmit={handleSubmit} />);\n  // \ud83d\udca3 this will blow up because the `getByLabelText` is actually querying the\n  // entire document, and because we didn\'t cleanup after the previous test\n  // we\'ll get an error indicating that RTL found more than one field with the\n  // label "username"\n  userEvent.type(getByLabelText(/username/i), "kentcdodds");\n  // more test here\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Fixing this is pretty simple, you need to execute the ",(0,i.jsx)(n.code,{children:"cleanup"})," method from ",(0,i.jsx)(n.code,{children:"@testing-library/react"})," after each test."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { cleanup, render } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport * as React from "react";\n\nimport Login from "../login";\n\ntest("example 1", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText } = render(<Login onSubmit={handleSubmit} />);\n  userEvent.type(getByLabelText(/username/i), "kentcdodds");\n  userEvent.type(getByLabelText(/password/i), "ilovetwix");\n  // more test here\n  cleanup();\n});\n\ntest("example 2", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText } = render(<Login onSubmit={handleSubmit} />);\n  userEvent.type(getByLabelText(/username/i), "kentcdodds");\n  // more test here\n  cleanup();\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"However, if you don't use afterEach to do this then if a test fails your cleanup wont run, like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'test("example 1", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText } = render(<Login onSubmit={handleSubmit} />);\n  userEvent.type(getByLabelText(/username/i), "kentcdodds");\n  // \ud83d\udca3 the following typo will result in a error thrown:\n  //   "no field with the label matching passssword"\n  userEvent.type(getByLabelText(/passssword/i), "ilovetwix");\n  // more test here\n  cleanup();\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Because of this, the ",(0,i.jsx)(n.code,{children:"cleanup"}),' function in "example 1" will not run and then "example 2" wont run properly, so instead of only seeing 1 test failure, you\'ll see that all the tests failed and it\'ll make it much harder to debug.']}),"\n",(0,i.jsxs)(n.p,{children:["So instead, you should use ",(0,i.jsx)(n.code,{children:"afterEach"})," and that will ensure that even if your test fails, you can cleanup:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'import { cleanup, render } from "@testing-library/react";\nimport userEvent from "@testing-library/user-event";\nimport * as React from "react";\n\nimport Login from "../login";\n\nafterEach(() => cleanup());\n\ntest("example 1", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText } = render(<Login onSubmit={handleSubmit} />);\n  userEvent.type(getByLabelText(/username/i), "kentcdodds");\n  userEvent.type(getByLabelText(/password/i), "ilovetwix");\n  // more test here\n});\n\ntest("example 2", () => {\n  const handleSubmit = jest.fn();\n  const { getByLabelText } = render(<Login onSubmit={handleSubmit} />);\n  userEvent.type(getByLabelText(/username/i), "kentcdodds");\n  // more test here\n});\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Even better, with React Testing Library, cleanup is called after each test automatically by default. Learn more in the docs"})}),"\n",(0,i.jsxs)(n.p,{children:["In addition, sometimes there are definitely good use cases for ",(0,i.jsx)(n.code,{children:"before*"}),", but they're normally matched with a cleanup that's necessary in an ",(0,i.jsx)(n.code,{children:"after*"}),". Like starting and stopping a server:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"let server;\nbeforeAll(async () => {\n  server = await startServer();\n});\nafterAll(() => server.close());\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There's not really any other reliable way to do this. Another use case I can think of that I've used these hooks is for testing ",(0,i.jsx)(n.code,{children:"console.error"})," calls:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'beforeAll(() => {\n  jest.spyOn(console, "error").mockImplementation(() => {});\n});\n\nafterEach(() => {\n  console.error.mockClear();\n});\n\nafterAll(() => {\n  console.error.mockRestore();\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"So there are definitely use cases for those kinds of hooks. I just don't recommend them as a mechanism for code reuse. We have functions for that."})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"I hope this helps clarify what I meant in this tweet:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"This pattern:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'test("whatever", () => {\n  const foo = someThing();\n  // use foo\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"makes for a WAY simpler testbase than:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:'let foo;\nbeforeEach(() => {\n  foo = someThing();\n});\n\ntest("whatever", () => {\n  // use foo\n});\n'})}),"\n",(0,i.jsx)(n.p,{children:"Avoid mutable variables. Your tests will be easier to understand"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"I've written tens of thousands of tests with different frameworks and styles and in my experience, reducing the amount of variable mutation has resulted in vastly simpler test maintenance. Good luck!"})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3774:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6672);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);